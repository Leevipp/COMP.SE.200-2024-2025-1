import toInteger from '../src/toInteger.js';

describe("tests for toInteger", () => {
    test("when given an integer, it should return the same integer", () => {
        const value = 5;
        const result = toInteger(value);
        expect(result).toBe(5);
    });

    test("when given a float, it should return the integer with the fraction dropped", () => {
        const value = 3.2;
        const result = toInteger(value);
        expect(result).toBe(3);
    });

    test("when given a string float, it should return the integer with the fraction dropped", () => {
        const value = "3.2";
        const result = toInteger(value);
        expect(result).toBe(3);
    });

    test("when given a negative float, it should return the integer with the fraction dropped", () => {
        const value = -3.2;
        const result = toInteger(value);
        expect(result).toBe(-3);
    });

    test("when given a negative string float, it should return the integer with the fraction dropped", () => {
        const value = "-3.2";
        const result = toInteger(value);
        expect(result).toBe(-3);
    });

    test("should return 0 when given an empty string", () => {
        const value = "";
        const result = toInteger(value);
        expect(result).toBe(0);
    })

    test("should return 0 when given a non-numeric string", () => {
        const value = "abc";
        const result = toInteger(value);
        expect(result).toBe(0);
    });

});


describe("additional tests, generated by AI (Gemini Flash 2.5 model)", () => {
    // Test Case 1: Positive floating-point numbers (standard truncation)
    test('should truncate positive floating point numbers towards zero', () => {
        expect(toInteger(4.9)).toBe(4);
        expect(toInteger(1.00001)).toBe(1);
        expect(toInteger(0.999)).toBe(0);
    });

    // Test Case 2: Negative floating-point numbers (standard truncation)
    test('should truncate negative floating point numbers towards zero', () => {
        expect(toInteger(-4.9)).toBe(-4);
        expect(toInteger(-1.00001)).toBe(-1);
        expect(toInteger(-0.999)).toBe(0);
    });

    // Test Case 3: Already integers
    test('should return the value for integers', () => {
        expect(toInteger(5)).toBe(5);
        expect(toInteger(-5)).toBe(-5);
        expect(toInteger(0)).toBe(0);
    });

    // Test Case 4: Special Numbers & Constants
    test('should handle Infinity and -Infinity by clamping to MAX/MIN safe integer', () => {
        // Expected behavior based on JSDoc example and standard toFinite
        const MAX_VAL = 1.7976931348623157e+308; // Number.MAX_VALUE

        expect(toInteger(Infinity)).toBe(MAX_VAL);
        expect(toInteger(-Infinity)).toBe(-MAX_VAL);
        expect(toInteger(Number.MAX_VALUE)).toBe(MAX_VAL);
        expect(toInteger(Number.MIN_VALUE)).toBe(0); // Very small positive number, truncates to 0
        expect(toInteger(NaN)).toBe(0); // toFinite(NaN) -> 0
    });

    // Test Case 5: String Inputs
    test('should convert and truncate numeric strings', () => {
        expect(toInteger('3.2')).toBe(3);
        expect(toInteger('-7.8')).toBe(-7);
        expect(toInteger('42')).toBe(42);
        expect(toInteger('-10')).toBe(-10);
    });

    test('should convert and handle non-numeric strings', () => {
        expect(toInteger('abc')).toBe(0); // toFinite('abc') -> 0
        expect(toInteger('')).toBe(0);    // toFinite('') -> 0
    });

    // Test Case 6: Other Primitive Types
    test('should convert and truncate other primitives', () => {
        expect(toInteger(true)).toBe(1);  // toFinite(true) -> 1
        expect(toInteger(false)).toBe(0); // toFinite(false) -> 0
        expect(toInteger(null)).toBe(0);  // toFinite(null) -> 0
        expect(toInteger(undefined)).toBe(0); // toFinite(undefined) -> 0 (Note: toFinite(undefined) -> 0)
    });

    // Test Case 7: Objects and Arrays
    test('should convert and handle complex types', () => {
        // Assuming standard coercion rules: Number([4.5]) -> 4.5
        expect(toInteger([4.5])).toBe(4);
        expect(toInteger([-5.5])).toBe(-5);

        // Assuming standard coercion rules: Number([]) -> 0
        expect(toInteger([])).toBe(0);

        // Assuming standard coercion rules: Number([1, 2]) -> NaN -> 0
        expect(toInteger([1, 2])).toBe(0);

        // Assuming standard coercion rules: Number({}) -> NaN -> 0
        expect(toInteger({})).toBe(0);

        // Test a custom object with a valueOf method
        const obj = { valueOf: () => 10.7 };
        expect(toInteger(obj)).toBe(10);
    });
});